-- OpenCode provider: plugin installer for .opencode/plugin

local M = {}

local utils = require 'nvim-claude.utils'

local function plugin_root()
  local src = debug.getinfo(1, 'S').source:sub(2)
  local root = src:match('(.*/)lua/nvim%-claude/')
  if root then
    if root:sub(-1) ~= '/' then
      root = root .. '/'
    end
    return root
  end
  local fallback = vim.fn.fnamemodify(src, ':h:h:h:h') .. '/'
  if fallback:sub(-1) ~= '/' then
    fallback = fallback .. '/'
  end
  return fallback
end

local function ensure_plugin_dir()
  local project_root = utils.get_project_root()
  if not project_root then
    return nil, 'Not in a git repository'
  end
  local plugin_dir = project_root .. '/.opencode/plugin'
  if vim.fn.isdirectory(plugin_dir) == 0 then
    local ok = vim.fn.mkdir(plugin_dir, 'p')
    if ok ~= 1 then
      return nil, 'Failed to create .opencode/plugin directory'
    end
  end
  return plugin_dir
end

local function escape_js_single_quotes(value)
  return value:gsub('\\', '\\\\'):gsub("'", "\\'"):gsub('%%', '%%%%')
end

local function plugin_template(root)
  local root_escaped = escape_js_single_quotes(root)
  local template = [[
// Generated by nvim-claude (OpenCode provider)
import path from 'path'
import { Buffer } from 'buffer'

const pluginRoot = '__PLUGIN_ROOT__'
const rpcPath = path.join(pluginRoot, 'rpc', 'nvim-rpc.sh')

const toBase64 = (value) => {
  if (value === undefined || value === null) return ''
  return Buffer.from(String(value), 'utf8').toString('base64')
}

const normalizePath = (baseDir, filePath) => {
  if (!filePath || typeof filePath !== 'string') return null
  const trimmed = filePath.trim()
  if (!trimmed) return null
  if (path.isAbsolute(trimmed)) return path.normalize(trimmed)
  return path.resolve(baseDir, trimmed)
}

const getArgValue = (args, keys) => {
  if (!args || typeof args !== 'object') return null
  for (const key of keys) {
    const value = args[key]
    if (typeof value === 'string' && value.trim() !== '') return value
  }
  return null
}

const extractFilePath = (args) => getArgValue(args, ['file_path', 'filePath', 'path', 'file'])
const extractPatchText = (args) => getArgValue(args, ['patch_text', 'patchText', 'patch'])

const normalizeMetadata = (metadata) => {
  if (!metadata) return null
  if (typeof metadata === 'string') {
    try {
      return JSON.parse(metadata)
    } catch (error) {
      return null
    }
  }
  if (typeof metadata === 'object') return metadata
  return null
}

const extractPatchPaths = (baseDir, patchText) => {
  if (!patchText || typeof patchText !== 'string') return []
  const results = new Set()
  const lines = patchText.split(/\r?\n/)
  for (const line of lines) {
    const match = line.match(/^\*\*\* (?:Update|Add|Delete) File:\s*(.+)$/)
    if (!match) continue
    const filePath = normalizePath(baseDir, match[1])
    if (filePath) results.add(filePath)
  }
  return Array.from(results)
}

const extractChangedFiles = (baseDir, metadata) => {
  const meta = normalizeMetadata(metadata)
  if (!meta) return []
  const files = meta.files_changed || meta.filesChanged
  if (!Array.isArray(files)) return []
  return files.map((file) => normalizePath(baseDir, file)).filter(Boolean)
}

const isRmCommand = (command) => typeof command === 'string' && /^\s*rm\b/.test(command)

const buildLsCommand = (command) => command.replace(/^\s*rm\b/, 'ls -d')

const resolveRmTargets = async (baseDir, command, $) => {
  if (!isRmCommand(command)) return []
  const lsCommand = buildLsCommand(command)
  if (!lsCommand) return []
  try {
    const output = await $.cwd(baseDir).nothrow()`${{ raw: lsCommand }}`.text()
    if (!output) return []
    return output
      .split(/\r?\n/)
      .map((line) => line.trim())
      .filter((line) => line !== '' && !line.startsWith('ls:'))
      .map((line) => normalizePath(baseDir, line))
      .filter(Boolean)
  } catch (error) {
    return []
  }
}

const callAdapter = async ($, baseDir, targetFile, method, value) => {
  if (!method) return
  const payload = value === undefined || value === null || value === '' ? '' : toBase64(value)
  const expr = payload === ''
    ? `luaeval("require('nvim-claude.events.adapter').${method}()")`
    : `luaeval("require('nvim-claude.events.adapter').${method}('${payload}')")`
  const target = targetFile || baseDir
  try {
    // Use child_process.spawn directly to avoid any shell interpretation
    const { spawn } = await import('child_process')
    await new Promise((resolve) => {
      const proc = spawn(rpcPath, ['--remote-expr', expr], {
        env: { ...process.env, TARGET_FILE: target },
        stdio: 'ignore',
      })
      proc.on('close', resolve)
      proc.on('error', resolve)
    })
  } catch (error) {
    // Ignore RPC failures to avoid disrupting OpenCode
  }
}

export const NvimClaude = async ({ directory, worktree, $ }) => {
  const baseDir = path.resolve(directory || worktree || process.cwd())
  const pendingCalls = new Map()
  const seenMessages = new Set()

  return {
    'tool.execute.before': async (input, output) => {
      const callId = input && input.callID
      if (callId) {
        pendingCalls.set(callId, { tool: input.tool, args: output && output.args })
      }
      const tool = input && input.tool
      const args = output && output.args ? output.args : {}
      if (tool === 'edit' || tool === 'write') {
        const filePath = normalizePath(baseDir, extractFilePath(args))
        if (filePath) {
          await callAdapter($, baseDir, filePath, 'pre_tool_use_b64', filePath)
        }
        return
      }
      if (tool === 'patch') {
        const patchText = extractPatchText(args)
        const files = extractPatchPaths(baseDir, patchText)
        for (const filePath of files) {
          await callAdapter($, baseDir, filePath, 'pre_tool_use_b64', filePath)
        }
        return
      }
      if (tool === 'bash') {
        const command = args && args.command
        const targets = await resolveRmTargets(baseDir, command, $)
        for (const filePath of targets) {
          await callAdapter($, baseDir, filePath, 'track_deleted_file_b64', filePath)
        }
      }
    },
    'tool.execute.after': async (input, output) => {
      const callId = input && input.callID
      const stored = callId ? pendingCalls.get(callId) : null
      if (callId) pendingCalls.delete(callId)
      const tool = (stored && stored.tool) || (input && input.tool)
      const args = stored && stored.args ? stored.args : {}
      if (tool === 'edit' || tool === 'write') {
        const filePath = normalizePath(baseDir, extractFilePath(args))
        if (filePath) {
          await callAdapter($, baseDir, filePath, 'post_tool_use_b64', filePath)
        }
        return
      }
      if (tool === 'patch') {
        let files = extractChangedFiles(baseDir, output && output.metadata)
        if (files.length === 0) {
          const patchText = extractPatchText(args)
          files = extractPatchPaths(baseDir, patchText)
        }
        for (const filePath of files) {
          await callAdapter($, baseDir, filePath, 'post_tool_use_b64', filePath)
        }
        return
      }
      if (tool === 'bash') {
        const command = args && args.command
        const remaining = await resolveRmTargets(baseDir, command, $)
        for (const filePath of remaining) {
          await callAdapter($, baseDir, filePath, 'untrack_failed_deletion_b64', filePath)
        }
      }
    },
    'chat.message': async (input, output) => {
      if (!output || !output.message) return
      const message = output.message
      if (!message || message.role !== 'user') return
      const messageId = message.id || (input && input.messageID)
      if (messageId && seenMessages.has(messageId)) return
      if (messageId) seenMessages.add(messageId)
      const parts = Array.isArray(output.parts) ? output.parts : []
      const text = parts
        .filter((part) => part && part.type === 'text' && typeof part.text === 'string')
        .map((part) => part.text)
        .join('')
      if (!text || text.trim() === '') return
      await callAdapter($, baseDir, baseDir, 'user_prompt_submit_b64', text)
    },
  }
}
]]

  return template:gsub('__PLUGIN_ROOT__', root_escaped)
end

function M.install()
  local plugin_dir, err = ensure_plugin_dir()
  if not plugin_dir then
    vim.notify('nvim-claude: ' .. (err or 'Failed to prepare OpenCode plugin'), vim.log.levels.ERROR)
    return false
  end
  local plugin_file = plugin_dir .. '/nvim-claude.js'
  local content = plugin_template(plugin_root())
  local ok = utils.write_file(plugin_file, content)
  if not ok then
    vim.notify('nvim-claude: Failed to write OpenCode plugin', vim.log.levels.ERROR)
    return false
  end
  vim.notify('nvim-claude: OpenCode plugin installed', vim.log.levels.INFO)
  return true
end

function M.uninstall()
  local project_root = utils.get_project_root()
  if not project_root then
    vim.notify('nvim-claude: Not in a git repository', vim.log.levels.ERROR)
    return false
  end
  local plugin_file = project_root .. '/.opencode/plugin/nvim-claude.js'
  if utils.file_exists(plugin_file) then
    local ok = pcall(vim.fn.delete, plugin_file)
    if not ok then
      vim.notify('nvim-claude: Failed to remove OpenCode plugin', vim.log.levels.ERROR)
      return false
    end
  end
  vim.notify('nvim-claude: OpenCode plugin uninstalled', vim.log.levels.INFO)
  return true
end

return M
